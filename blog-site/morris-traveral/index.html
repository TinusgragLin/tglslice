<!DOCTYPE html>
<html lang="en">
    <head>
    <title>O(1) Extra Space Iterative BTree In-order Traversal - Morris Traversal - Tinusgraglin</title>
    
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"><meta name="description" content="A Slice O(1) Extra Space Iterative BTree In-order Traversal - Morris Traversal From the joy of no left sub-tree."/><meta name="keywords" content="algo, btree traversal" />
    <meta property="og:title" content="A Slice of Tgl -&nbsp;O(1) Extra Space Iterative BTree In-order Traversal - Morris Traversal" />
    <meta property="og:type" content="website"/><meta property="og:url" content="&#x2F;blog&#x2F;morris-traveral&#x2F;"/><meta property="og:description" content="From the joy of no left sub-tree."/>
    <link rel="preload" href="/blog/assets/fonts/FiraCode-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="/blog/assets/fonts/FiraCode-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <link rel="stylesheet" href="/blog/style.css?h=97e262212a0704163528">
    <link rel="stylesheet" href=" /blog/color/orange.css?h=a5a5d7faf9d4bc3e0b18">
    
</head>
    <body>
        <div class="container center">
<header class="header">
    <div class="header__inner">
        <div class="header__logo">
            <a href="&#x2F;blog">
    <div class="logo">
        LIN
    </div>
</a>
        </div>
        <div class="menu-trigger">menu</div>
    </div>
    
    <nav class="menu">
        <ul class="menu__inner menu__inner--desktop">
            
            
                    <li>
                        <a href="
    
        /blog/about
    
">about</a>
                    </li>
                
            </ul>

        <ul class="menu__inner menu__inner--mobile">
            
        <li>
            <a href="
    
        /blog/about
    
">about</a>
        </li>
        </ul>
    </nav>

    </header>
<div class="content"><article class="post">
        <header>
            <h1 class="post-title">
                <a href="&#x2F;blog&#x2F;morris-traveral&#x2F;">O(1) Extra Space Iterative BTree In-order Traversal - Morris Traversal</a>
            </h1>
            
    <div class="post-meta">
        <span class="post-date">2024.01.09
                </span>

        <span class="post-author"></span>

        

    
    :: {<a href="/blog/categories/algo/">algo</a>} 

            
    ::
    #<a href="/blog/tags/btree-traversal/">btree traversal</a>
        
    
            
        
    </div>

            
    


<div class="toc" id="nav-container">
	<p class="toc-head">Table of Contents</p>
		<div id="nav-content" >
		<ul>
		
			<li>
				<a href="/blog/morris-traveral/#backgound-traverse-a-binary-tree-without-recursion">Backgound: Traverse a Binary Tree without Recursion</a>
				
			</li>
		
			<li>
				<a href="/blog/morris-traveral/#traverse-a-right-skewed-tree-rst-is-too-easy">Traverse a Right-skewed Tree (RST) is Too Easy</a>
				
			</li>
		
			<li>
				<a href="/blog/morris-traveral/#a-transform-that-reduces-the-left-sub-tree-height-but-keeps-the-in-order-traversal">A Transform that Reduces the Left Sub-tree Height but Keeps the In-order Traversal</a>
				
			</li>
		
			<li>
				<a href="/blog/morris-traveral/#repair-the-tree">Repair the Tree</a>
				
					<ul>
						
							<li>
								<a href="/blog/morris-traveral/#only-add-the-link">Only Add the Link</a>
							</li>
							
						
							<li>
								<a href="/blog/morris-traveral/#determine-a-root">Determine a Root</a>
							</li>
							
						
							<li>
								<a href="/blog/morris-traveral/#when-should-we-repair">When Should We Repair?</a>
							</li>
							
						
					</ul>
				
			</li>
		
		</ul>
		</div>
</div>

</header><h1 id="backgound-traverse-a-binary-tree-without-recursion">Backgound: Traverse a Binary Tree without Recursion<a class="zola-anchor" href="#backgound-traverse-a-binary-tree-without-recursion" aria-label="Anchor link for: backgound-traverse-a-binary-tree-without-recursion">§</a>
</h1>
<p>Traverse a binary tree iteratively with an extra stack is known in early ages, in
1970s, Knuth gives an iterative traversal algorithm with 'tag' bits in nodes and
propose the problem of designing an alternative without explicit stack nor 'tag'
bits. In 1975, W.A. Burkhard came up with one that assumes all children nodes' address
is larger than the root. In 1979, Joseph M. Morris published his solution that
assumes nothing.</p>
<p>In the blog post, I will try to present (from my understanding) the key ideas of
<a href="https://doi.org/10.1016/0020-0190(79)90068-1">the 1975 paper</a> and develop the algorithm following the paper with these key
ideas.</p>
<h1 id="traverse-a-right-skewed-tree-rst-is-too-easy">Traverse a Right-skewed Tree (RST) is Too Easy<a class="zola-anchor" href="#traverse-a-right-skewed-tree-rst-is-too-easy" aria-label="Anchor link for: traverse-a-right-skewed-tree-rst-is-too-easy">§</a>
</h1>
<p>A right-skewed binary tree (right-skewed tree, or RST in the later discussion) is
a binary tree that always grows to the right.</p>
<p>To traverse a right-skewed tree is simply to traverse a singly linked list:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">rst_in_order_traversal</span><span>(Node *</span><span style="color:#bf616a;">root</span><span>) {
</span><span>    Node *cur_root = root;
</span><span>    </span><span style="color:#b48ead;">while </span><span>(cur_root != </span><span style="color:#d08770;">NULL</span><span>) {
</span><span>        </span><span style="color:#b48ead;">if </span><span>(cur_root.</span><span style="color:#bf616a;">left </span><span>== </span><span style="color:#d08770;">NULL</span><span>) {
</span><span>            </span><span style="color:#bf616a;">visit</span><span>(cur_root);
</span><span>            cur_root = cur_root.</span><span style="color:#bf616a;">right</span><span>;
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            </span><span style="color:#96b5b4;">printf</span><span>(&quot;</span><span style="color:#a3be8c;">Not a right-skewed tree!</span><span>&quot;);
</span><span>            </span><span style="color:#b48ead;">return</span><span>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>The first key idea of Morris traversal is just to transform a tree so that the
resulting tree has a lower left sub-tree but the same in-order traversal, keep
doing the transform until the resulting tree has no left sub-tree, so traversing
it is as simple as visit the root and traverse the right sub-tree.</p>
<h1 id="a-transform-that-reduces-the-left-sub-tree-height-but-keeps-the-in-order-traversal">A Transform that Reduces the Left Sub-tree Height but Keeps the In-order Traversal<a class="zola-anchor" href="#a-transform-that-reduces-the-left-sub-tree-height-but-keeps-the-in-order-traversal" aria-label="Anchor link for: a-transform-that-reduces-the-left-sub-tree-height-but-keeps-the-in-order-traversal">§</a>
</h1>
<p>Before introducing the transform, a quick question: what is the last node in an
in-order traverse of a tree? The rightmost node, i.e. the furthest node in the
'always-right' path. When this node is visited, its left sub-tree is already visited,
and since it has no right sub-tree, its parent's whole right sub-tree is visited,
so its grandparent's whole right sub-tree is visited, this chain continues upwards,
and at the end, the root's whole right sub-tree is visited, so the entire tree is
visited.</p>
<p>So, for a binary tree, its in-order traversal is like this:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>(left sub-tree in-order traversal) Root (right sub-tree in-order traversal)
</span><span>==
</span><span>(......................... RM_LST) Root (right sub-tree in-order traversal)
</span></code></pre>
<p>where <code>RM_LST</code> is the rightmost node of the left sub-tree (it it exists). But this is
equivalent to the case where the original <code>Root</code>'s left child is the root, and <code>RM_LST</code>
links to the original <code>Root</code> on the right, and the original <code>Root</code>'s left sub-tree is
empty. This is a transform that reduces the height of the left sub-tree of the tree we
are handling but keeps the in-order traversal.</p>
<p>With this transform, we can in-order traverse any tree by restructuring the tree when
necessary:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">in_order_traversal</span><span>(Node *</span><span style="color:#bf616a;">root</span><span>) {
</span><span>    Node *cur_root = root;
</span><span>    </span><span style="color:#b48ead;">while </span><span>(cur_root != </span><span style="color:#d08770;">NULL</span><span>) {
</span><span>        </span><span style="color:#b48ead;">if </span><span>(cur_root.</span><span style="color:#bf616a;">left </span><span>== </span><span style="color:#d08770;">NULL</span><span>) {
</span><span>            </span><span style="color:#bf616a;">visit</span><span>(cur_root);
</span><span>            cur_root = cur_root.</span><span style="color:#bf616a;">right</span><span>;
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            </span><span style="color:#65737e;">// the left sub-tree is not empty!
</span><span>
</span><span>            </span><span style="color:#65737e;">// find RM_LST:
</span><span>            Node *p = cur_root.</span><span style="color:#bf616a;">left</span><span>;
</span><span>            </span><span style="color:#b48ead;">while </span><span>(p.</span><span style="color:#bf616a;">r </span><span>!= </span><span style="color:#d08770;">NULL</span><span>) p = p.</span><span style="color:#bf616a;">r</span><span>;
</span><span>
</span><span>            </span><span style="color:#65737e;">// do the transform:
</span><span>            cur_root.</span><span style="color:#bf616a;">left </span><span>= </span><span style="color:#d08770;">NULL</span><span>;
</span><span>            p.</span><span style="color:#bf616a;">r </span><span>= cur_root;
</span><span>            cur_root = cur_root.</span><span style="color:#bf616a;">left</span><span>;
</span><span>
</span><span>            </span><span style="color:#65737e;">// after the transform, the left sub-tree is shorter by one level
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Starting from the root, we check if the left sub-tree is empty, if yes, we happily visit
the root and go handle the right sub-tree, if no, we do the transform to reduce the height
of the left sub-tree and try again.</p>
<h1 id="repair-the-tree">Repair the Tree<a class="zola-anchor" href="#repair-the-tree" aria-label="Anchor link for: repair-the-tree">§</a>
</h1>
<h2 id="only-add-the-link">Only Add the Link<a class="zola-anchor" href="#only-add-the-link" aria-label="Anchor link for: only-add-the-link">§</a>
</h2>
<p>The repairing of the re-structurings of the above approach is very complax since we not
only add links but also delete original ones. The second key idea of Morris traversal is
that maybe we can just add a link from a <code>RM_LST</code>'s right side to the <code>Root</code>, but do not
delete the <code>Root</code>'s left link <em>as long as when handling the <code>Root</code>, we ignore its left sub-tree.</em></p>
<h2 id="determine-a-root">Determine a <code>Root</code><a class="zola-anchor" href="#determine-a-root" aria-label="Anchor link for: determine-a-root">§</a>
</h2>
<p>But how do we know that a node is a <code>Root</code> in the transform process? Well, if its <code>RM_LST</code>'s
right link goes towards it. Notice that, examine whether a node is a <code>Root</code> requires us
to examine whether its <code>RM_LST</code> points to it, which, gives us an good opportunity to delete
the added link, repairing this one re-structuring. However, should we do that? What if
this re-structuring is still needed?</p>
<h2 id="when-should-we-repair">When Should We Repair?<a class="zola-anchor" href="#when-should-we-repair" aria-label="Anchor link for: when-should-we-repair">§</a>
</h2>
<p>Looking back, the re-structuring happens exactly when the root's left sub-tree has to be
handled, at this kind of moment, we do 'turn to' the left sub-tree to handle it first, but
with an addition to the original tree structure: the rightmost node of the left sub-tree
now points to the root -- an addition to the left sub-tree of the original tree, to be exact.</p>
<p>Therefore when we are done with this left sub-tree, it's probably time that we repair the
destruction. When is the end of the traversal of this left sub-tree? Exactly when we
visit the <code>Root</code>, which, if you look back a little, is exactly when we can determine that a
node is the <code>Root</code>, since its left sub-tree is ignored. So yes, if we can determine that
a node is a <code>Root</code> by checking if its <code>RM_LST</code> points to it, we should do the repairing!</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">rst_in_order_traversal</span><span>(Node *</span><span style="color:#bf616a;">root</span><span>) {
</span><span>    Node *cur_root = root;
</span><span>    </span><span style="color:#b48ead;">while </span><span>(cur_root != </span><span style="color:#d08770;">NULL</span><span>) {
</span><span>        </span><span style="color:#b48ead;">if </span><span>(cur_root.</span><span style="color:#bf616a;">left </span><span>== </span><span style="color:#d08770;">NULL</span><span>) {
</span><span>            </span><span style="color:#bf616a;">visit</span><span>(cur_root);
</span><span>            cur_root = cur_root.</span><span style="color:#bf616a;">right</span><span>;
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            </span><span style="color:#65737e;">// The left sub-tree is not empty!
</span><span>
</span><span>            </span><span style="color:#65737e;">// Find RM_LST (that either has been modified and has not been modified):
</span><span>            Node *p = cur_root.</span><span style="color:#bf616a;">left</span><span>;
</span><span>            </span><span style="color:#b48ead;">while </span><span>(p.</span><span style="color:#bf616a;">r </span><span>!= </span><span style="color:#d08770;">NULL </span><span>|| p.</span><span style="color:#bf616a;">r </span><span>!= cur_root) p = p.</span><span style="color:#bf616a;">r</span><span>;
</span><span>
</span><span>            </span><span style="color:#b48ead;">if </span><span>(p.</span><span style="color:#bf616a;">r </span><span>== </span><span style="color:#d08770;">NULL</span><span>) {
</span><span>                </span><span style="color:#65737e;">// Get a RM_LST that has not been modified, we do the transform:
</span><span>                p.</span><span style="color:#bf616a;">r </span><span>= cur_root;
</span><span>                cur_root = cur_root.</span><span style="color:#bf616a;">left</span><span>;
</span><span>            } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                </span><span style="color:#65737e;">// Get a RM_LST that has been modified, so we just find that `cur_root`
</span><span>                </span><span style="color:#65737e;">// is a `Root`, we do the repairing:
</span><span>                p.</span><span style="color:#bf616a;">r </span><span>= </span><span style="color:#d08770;">NULL</span><span>;
</span><span>
</span><span>                </span><span style="color:#65737e;">// We ignore the sub-tree of `cur_root` since it&#39;s a `Root`, and turns
</span><span>                </span><span style="color:#65737e;">// to its right sub-tree:
</span><span>                </span><span style="color:#bf616a;">visit</span><span>(cur_root);
</span><span>                cur_root = cur_root.</span><span style="color:#bf616a;">right</span><span>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>


        
    

        
        
    </article></div>
    <div class="pagination">
        <div class="pagination__buttons">
            </div>
    </div>
<footer class="footer">
                    <div class="footer__inner"><div class="copyright">
            <span>© 2024 Tinusgraglin <span/>
            <span>:: Powered by <a href="https://www.getzola.org/">Zola</a>(<a href="https://www.rust-lang.org/">Rust</a>) and <a href="https://bun.sh">Bun</a>(<a href="https://ziglang.org">Zig</a>)</span>
        </div>
    <script type="text/javascript" src="/blog/assets/js/main.js"></script>
</div>
                    

                </footer></div>
    </body>
</html>
